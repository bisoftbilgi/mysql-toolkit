input {
  file {
    path => ["${MYSQL_GENERAL_LOG_PATH}"]
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb_mysql_general""
    codec => plain { charset => "UTF-8" }
  }
}

filter {
  # ECS on/off normalize
  if ![path] and [log][file][path] {
    mutate { replace => { "path" => "%{[log][file][path]}" } }
  }

  # /logs/mysql-01/general-query.log -> server_id=mysql-01
  dissect { mapping => { "path" => "/logs/%{server_id}/%{filename}" } }

  translate {
    field           => "server_id"
    destination     => "server_meta_json"
    dictionary_path => "/usr/share/logstash/extra/servers.yml"
    fallback        => "{\"cluster_name\":\"unknown\",\"server_name\":\"unknown\",\"server_ip\":\"0.0.0.0\"}"
  }

  json { source => "server_meta_json" target => "server_meta" }

  mutate {
    replace => {
      "cluster_name" => "%{[server_meta][cluster_name]}"
      "server_name"  => "%{[server_meta][server_name]}"
      "server_ip"    => "%{[server_meta][server_ip]}"
    }
    remove_field => ["server_meta_json","server_meta"]
  }

  ##############################
  ## GROK PARSING
  ##############################
  grok {
    match => {
      "message" => [
        # CONNECT SUCCESS: 2025-12-04T10:54:04.467089Z        13 Connect   root@localhost on system_logs using Socket
        "%{TIMESTAMP_ISO8601:timestamp}\s+%{INT:connection_id}\s+Connect\s+%{USERNAME:user}@%{DATA:client_host}\s+on\s+%{DATA:database}\s+using\s+%{WORD:protocol}",
        
        # ACCESS DENIED: 2025-12-04T10:55:38.871158Z        14 Connect   Access denied for user 'root'@'localhost' (using password: YES)
        "%{TIMESTAMP_ISO8601:timestamp}\s+%{INT:connection_id}\s+Connect\s+Access denied for user '%{USERNAME:denied_user}'@'%{DATA:denied_host}'.*",
        
        # QUERY: 2025-12-04T10:54:04.488637Z        13 Query     show databases
        "%{TIMESTAMP_ISO8601:timestamp}\s+%{INT:connection_id}\s+Query\s+%{GREEDYDATA:query}",
        
        # FIELD LIST: 2025-12-04T10:54:04.490634Z        13 Field List        logtest
        "%{TIMESTAMP_ISO8601:timestamp}\s+%{INT:connection_id}\s+Field List\s+%{GREEDYDATA:table_name}",
        
        # QUIT: 2025-12-04T10:55:37.166019Z        13 Quit
        "%{TIMESTAMP_ISO8601:timestamp}\s+%{INT:connection_id}\s+Quit"
      ]
    }
  }

  # Parse timestamp
  date {
    match => ["timestamp", "ISO8601"]
    target => "log_time"
  }

  # Clean whitespace
  mutate { 
    strip => ["query", "user", "database", "table_name"] 
  }

  #########################################
  ## ACCESS DENIED - Process First
  #########################################
  if "Access denied" in [message] {
    mutate {
      add_field => {
        "event_type" => "connection"
        "action"     => "AccessDenied"
        "client_ip"  => "%{denied_host}"
        "user"       => "%{denied_user}"
      }
    }
    # No cache creation needed for Access Denied
  }

  #########################################
  ## CONNECT SUCCESS - Create Cache
  #########################################
  else if ("Connect" in [message]) and [user] {
    mutate {
      add_field => { 
        "event_type" => "connection"
        "action"     => "Connect"
        "client_ip"  => "%{client_host}"
      }
    }

    # IMPORTANT: requires pipeline.workers: 1
    aggregate {
      task_id => "%{connection_id}"
      map_action => "create"
      timeout => 3600
      code => "
        map['user'] = event.get('user')
        map['database'] = event.get('database')
        map['client_ip'] = event.get('client_host')
        map['protocol'] = event.get('protocol')
      "
    }
  }

  #########################################
  ## QUERY - Audit Log
  #########################################
  else if "Query" in [message] {
    mutate {
      add_field => {
        "event_type"     => "audit"
        "command"        => "Query"
        "statement_text" => "%{query}"
      }
    }

    # Audit Type Detection
    if [query] =~ "(?i)^\s*select" {
      mutate { add_field => { "audit_type" => "DQL" } }
    }
    else if [query] =~ "(?i)^\s*(insert|update|delete)" {
      mutate { add_field => { "audit_type" => "DML" } }
    }
    else if [query] =~ "(?i)^\s*(create|alter|drop|truncate|rename)" {
      mutate { add_field => { "audit_type" => "DDL" } }
    }
    else if [query] =~ "(?i)^\s*(grant|revoke|deny)" {
      mutate { add_field => { "audit_type" => "DCL" } }
    }
    else if [query] =~ "(?i)^\s*(show|describe|explain|desc)" {
      mutate { add_field => { "audit_type" => "SHOW" } }
    }
    else if [query] =~ "(?i)^\s*(commit|rollback|savepoint|start\s+transaction|begin)" {
      mutate { add_field => { "audit_type" => "TCL" } }
    }
    else {
      mutate { add_field => { "audit_type" => "OTHER" } }
    }

    # Object Detection for DDL/DML/DCL
    if [audit_type] in ["DDL", "DML", "DCL"] {
      grok {
        match => {
          "query" => [
            # DDL: CREATE/ALTER/DROP TABLE/DATABASE/INDEX/VIEW
            "(?i)^\s*(create|alter|drop)\s+(table|database|index|view)\s+(if\s+(not\s+)?exists\s+)?`?(?<object_name>[^\s`(]+)",
            # DML: INSERT INTO
            "(?i)^\s*insert\s+into\s+`?(?<object_name>[^\s`(]+)",
            # DML: UPDATE
            "(?i)^\s*update\s+`?(?<object_name>[^\s`]+)",
            # DML: DELETE FROM
            "(?i)^\s*delete\s+from\s+`?(?<object_name>[^\s`]+)",
            # DCL: GRANT ... ON [database.]table TO user
            "(?i)^\s*grant\s+.+\s+on\s+(table\s+)?`?(?<object_name>[^\s`@]+?)(`|\s+to)",
            # DCL: REVOKE ... FROM user
            "(?i)^\s*revoke\s+.+\s+from\s+`?['\"]?(?<object_name>[^'\"@`\s]+)"
          ]
        }
        tag_on_failure => []
      }
      if [object_name] {
        mutate { 
          strip => ["object_name"]
          gsub => [
            "object_name", "`", "",
            "object_name", "'", "",
            "object_name", "\"", "",
            "object_name", "\(.*", "",
            "object_name", "^.*\.", ""
          ]
        }
      }
    }

    # Retrieve user info from cache
    aggregate {
      task_id => "%{connection_id}"
      map_action => "update"
      code => "
        event.set('user', map['user']) if map['user']
        event.set('database', map['database']) if map['database']
        event.set('client_ip', map['client_ip']) if map['client_ip']
      "
    }

    # Application Name Detection
    if [query] =~ "(?i)@@version" or [query] =~ "(?i)@@hostname" {
      mutate { replace => { "application_name" => "mysql-client" } }
    }
    else if [query] =~ "(?i)information_schema" {
      mutate { replace => { "application_name" => "mysql-driver" } }
    }
  }

  #########################################
  ## FIELD LIST - Audit Log
  #########################################
  else if "Field List" in [message] {
    mutate {
      add_field => {
        "event_type"     => "audit"
        "command"        => "FieldList"
        "statement_text" => "DESCRIBE %{table_name}"
        "audit_type"     => "SHOW"
        "object_name"    => "%{table_name}"
      }
    }

    aggregate {
      task_id => "%{connection_id}"
      map_action => "update"
      code => "
        event.set('user', map['user']) if map['user']
        event.set('database', map['database']) if map['database']
        event.set('client_ip', map['client_ip']) if map['client_ip']
      "
    }
  }

  #########################################
  ## QUIT - Connection Close
  #########################################
  else if "Quit" in [message] {
    
    # If no connection_id, drop event (likely a fragment)
    if ![connection_id] {
      drop { }
    }

    mutate {
      add_field => {
        "event_type" => "connection"
        "action"     => "Quit"
      }
    }

    # Retrieve final user info and clear cache
    aggregate {
      task_id => "%{connection_id}"
      map_action => "update"
      end_of_task => true
      code => "
        # Only populate event if data exists in cache
        if map['user']
          event.set('user', map['user'])
          event.set('database', map['database']) if map['database']
          event.set('client_ip', map['client_ip']) if map['client_ip']
        else
          # Drop event if no cache data found (orphaned quit)
          event.cancel
        end
        map.clear
      "
    }
  }

  # Drop unmatched events
  else {
    drop { }
  }

  # Remove temporary fields
  mutate {
    remove_field => [
      "message", "host", "path", "@version",
      "denied_user", "denied_host", "client_host",
      "protocol", "table_name", "query", "timestamp"
    ]
  }

}

#########################################################
## OUTPUT - POSTGRESQL
#########################################################
output {

  ############################
  ## CONNECTION LOGS
  ############################
  if [event_type] == "connection" {
    jdbc {
      connection_string => "jdbc:postgresql://${PG_HOST}:${PG_PORT}/${PG_DB_NAME}"
      driver_class => "org.postgresql.Driver"
      username => "${PG_USER}"
      password => "${PG_PASSWORD}"

      statement => [
        "INSERT INTO ${PG_CONN_TABLE:mysql_connection_logs} (
           log_time, username, database_name, client_ip, action,
           cluster_name, server_name, server_ip, application_name
         ) VALUES (?::timestamptz, ?, ?, ?, ?, ?, ?, ?, ?)",

        "log_time", "user", "database", "client_ip", "action",
        "cluster_name", "server_name", "server_ip", "application_name"
      ]
    }
  }

  ############################
  ## AUDIT LOGS
  ############################
  if [event_type] == "audit" {
    jdbc {
      connection_string => "jdbc:postgresql://${PG_HOST}:${PG_PORT}/${PG_DB_NAME}"
      driver_class => "org.postgresql.Driver"
      username => "${PG_USER}"
      password => "${PG_PASSWORD}"

      statement => [
        "INSERT INTO ${PG_AUDIT_TABLE:mysql_audit_logs} (
           log_time, username, database_name, session_id, audit_type,
           statement_text, command, object_type, object_name,
           cluster_name, server_name, server_ip, client_ip, application_name
         ) VALUES (?::timestamptz, ?, ?, ?::bigint, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",

        "log_time", "user", "database", "connection_id", "audit_type",
        "statement_text", "command", "object_type", "object_name",
        "cluster_name", "server_name", "server_ip", "client_ip", "application_name"
      ]
    }
  }
  stdout { codec => rubydebug { metadata => false } }
}
